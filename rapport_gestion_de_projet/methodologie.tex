\subsection{Travail en groupe}

\paragraph{}
Afin d'optimiser notre travail, nous nous répartissons le travail. Chacun sait donc ce qu'il doit faire de son coté. Cependant il est sans arrêts nécessaire de communiquer. C'est pourquoi nous utilisons des outils que nous décrirons plus tard, nous restons disponibles sur Jabber pour discuter ensemble des problèmes que nous rencontrons, mais surtout, nous faisons des réunions de groupes régulièrement. Ces réunions sont le plus souvent pendant les créneaux prévus dans l'emploi du temps. Seulement ces créneaux ne nous arrangent pas forcément donc des fois nous le faisons à d'autres moments de la semaine si besoin est.

\paragraph{}
Pour éviter de travailler seul chacun dans son coin, nous avons créé deux binômes dans le groupe qui vérifient le travail de l'autre. Ceci permet d'avoir les avantages du travail de groupe tout en restant en très petit commité ce qui permet une avancée rapide. Ces revues sont gérées à l'aide d'outils que nous présenterons plus tard.

\subsection{Outils de travail}

\paragraph{}
Nous avons décidé d'utiliser plusieurs outils pour optimiser le travail en groupe. Avant de commencer à travailler, nous avons découpé le projet en plusieurs versions. Chaque version est numérotée et se voit assigné plusieurs fonctionnalités ainsi qu'une date butoire. Une fois toutes ces fonctionnalités terminées, la version est sauvegardée et nous commençons à travailler sur la suivant. Pour gérer ce système de version et de fonctionnalités, nous utilisons redmine qui est un outil adapté à nos besoins. Il permet la gestion des demandes et l'assignation à un membre de l'équipe. Nous utilisons avec redmine le gestionnaire de version Git qui pour nous est le plus pratique à l'heure actuelle notamment grâce à sa simplicité de gestion des branches. Pour gérer l'avancée du projet, nous avons suivi une méthodologie très structurée. Nous avons une branche master qui est la branche stable du projet. Nous avons ensuite une version de developpement. Nous ne travaillons pas directement sur cette branche. A chaque fois que nous souhaitons ajouter une fonctionnalité nécessitant plus d'un commit, nous créons une nouvelle branche pour cette fonctionnalité. Une fois celle-ci mise en place, nous envoyons les modifications sur la branche de développement. Dès que toutes les fonctionnalités d'une version sont terminées, nous envoyons les modifications sur la branche principale que nous taggons du numéro de version.

\section{Pron}

\subsection{Rôle et fonctionnalités}

Pron est notre système de fenêtrage, également appelé ``serveur graphique'' car il permet à différents clients (les applications) de créer des fenêtres, qui ne sont à ce niveau que de simples zones de dessin rectangulaires. Il leur propose pour cela des primitives de dessin basiques :
\begin{itemize}
\item Création et gestion (redimensionnement, déplacement, effacement, destruction) de zones de dessin
\item Dessin de formes géométriques (points, lignes, rectangles, ellipses...)
\item Dessin de texte parmi un choix de polices de caractères supportées
\item Affichage d'images
\end{itemize}

\vspace{1em}

C'est également lui qui dialogue avec les périphériques et gère les entrées/sorties :
\begin{itemize}
  \item Périphériques d'entrée (clavier, souris), afin de détecter et de transmettre des événements aux applications (touche ``a'' appuyée, bouton gauche de la souris enfoncé dans telle ou telle fenêtre...)
  \item Périphériques de sortie (carte vidéo), afin d'afficher le pointeur de la souris et l'ensemble des fenêtres à l'écran.
\end{itemize}

\subsection{Description du protocole utilisé}

Le protocole de communication entre Pron et ses clients comporte quatre catégorie de messages :
\begin{itemize}
  \item \textbf{requête :} demande d'un client au serveur (création de fenêtre, dessin de ligne, récupération des attributs d'une fenêtre...). Ne nécessite pas forcément une réponse.
  \item \textbf{réponse :} réponse du serveur suite à une requête (message de bienvenue, valeurs des attributs demandés...)
  \item \textbf{événement :} message envoyé par le serveur lorsqu'un événement survient (entrée clavier ou souris, exposition d'une fenêtre...)
  \item \textbf{erreur :} envoyé par le serveur suite à une requête invalide (dessin dans une fenêtre inexistante, attributs incorrects...)
\end{itemize}

\vspace{1em}

Les types de messages sont codés sur 4 octets. La catégorie est identifiée par les deux octets de poids fort\footnote{Oui, c'est large !}. On peut donc avoir $2^{16} = 65536$ événements par catégorie (codés sur les deux octets restants)\footnote{C'est large aussi.}. Par exemple, un message de type \verb|EV_EXPOSE| (événement d'exposition) a un type égal à \verb|0x20003| : \verb|0x2 << 16| (identifiant de la catégorie ``événements'') \verb=| 0x3= (l'événement d'exposition est le 3ème message de la catégorie des événements).

Afin d'optimiser les performances, une requête n'attend pas forcément une réponse. La plupart des requêtes sont au contraire conçues de manière à ce qu'une réponse ne soit pas nécessaire. Toutes les requêtes de création de ressources par exemple (fenêtres, pixmaps, contextes graphiques...) fournissent elles-mêmes l'identifiant de la ressource qu'elles veulent créer. Cela permet de ne pas attendre une réponse du serveur indiquant l'identifiant de la ressource nouvellement créée.

Les identifiants de ressources sont codés sur 4 octets, avec l'identifiant du client sur les deux octets de poids fort. On peut donc avoir $65536$ clients différents, qui créent chacun $65536$ ressources. Chaque client peut donc demander à créer une ressource dans l'intervalle d'identifiants $[id_{client} << 16 ; (id_{client} + 1) << 16 - 1]$.

\subsection{Architecture et description des acteurs}
\label{Architecture}
Le graphe de collaboration ci-dessous présente les classes principales de pron, articulées autour d'une classe centrale : \verb|Screen|.

\begin{figure}[H]
  \centering
  \includegraphics[width=14cm]{images/collab_screen.png}
  \caption{Diagramme de collaboration articulé autour de la classe Screen}
\end{figure}

Dans cette section, nous allons présenter brièvement les différents acteurs qui composent Pron. Le \verb|Screen| ne sera pas présenté le premier, car il dépend de beaucoup d'autres acteurs que nous devons introduire au préalable.

\subsubsection{Graphics Contexts}

Les GC (graphics contexts, ou contextes graphiques) contiennent les paramètres graphiques utilisés par toutes les primitives de dessin :
\begin{itemize}
  \item Couleur d'avant-plan
  \item Couleur d'arrière-plan
  \item Police de caractères utilisée
\end{itemize}

\vspace{1em}

L'utilisation des contextes graphiques permet d'éviter de repasser tous ces paramètres à chaque appel d'une primitive de dessin. Cela permet également à l'utilisateur de créer des ``environnements graphiques'' qu'il peut réutiliser. Leur contenu est pour l'instant restreint, mais il sera étendu à l'avenir (largeur des traits, style de ligne, style de remplissage...).

Toutes les primitives de dessin utilisent le contexte graphique configuré au moment de leur appel. Les requêtes de dessin contiennent toujours le contexte graphique à utiliser, qui peut donc être configuré par la méthode \verb|prepareDrawing| de la classe \verb|Screen| avant l'invocation de la primitive de dessin demandée.

\paragraph{Couleurs}
Nous avons créé une classe \verb|Color| afin de manipuler les couleurs et les échanger entre le client et le serveur. Elle permet de manipuler les couleurs facilement (diférents constructeurs acceptant des composantes RVB de 0 à 255, de 0 à 1 (flottant), des codes couleurs hexadécimaux ; getters/setters composante par composante...) mais offre surtout une représentation interne unique : des composantes RVB flottantes de 0 à 1. Cela permet de manipuler les couleurs indépendamment de la profondeur de couleurs utilisée sur le serveur : la conversion est effectuée au dernier moment, lors de la création ou de la modification du contexte graphique sur le serveur. Les clients peuvent ainsi utiliser n'importe quelle couleur, la conversion dans la profondeur utilisée par le serveur graphique (16 couleurs, 256 couleurs, 16 bits, 24 bits, 32 bits...) sera effectuée de manière totalement transparente.

\subsubsection{Drawable}

Jusqu'à présent, nous avions appelé ``fenêtres'' les zones de dessin rectangulaires gérées par le serveur graphique. Il existe en réalité deux types de zones de dessin :
\begin{itemize}
  \item Les \textbf{Window}, qui sont des fenêtres affichées à l'écran et ne sont pas stockées en mémoire. Si elle est obscurcie (par une autre \verb|Window|, ou parce qu'elle est déplacée en dehors de l'écran), l'application qui l'a créée devra la redessiner (entièrement ou en partie, nous verrons comment dans la section \ref{evenements}).
  \item Les \textbf{Pixmap}, qui sont des zones de dessin stockées en mémoire et non visibles à l'écran. Une pixmap peut cependant être copiée dans une \verb|Window| à tout moment (et vice-versa).
\end{itemize}

\vspace{1em}

Tous les \verb|Drawable| proposent les primitives de dessin suivantes :
\begin{itemize}
  \item \textbf{drawPoint :} dessin d'un point
  \item \textbf{drawLine :} dessin d'une ligne
  \item \textbf{drawRect :} dessin d'un rectangle
  \item \textbf{drawEllipse :} dessin d'une ellipse
  \item \textbf{fillRect :} dessin d'un rectangle rempli
  \item \textbf{fillEllipse :} dessin d'une ellipse remplie
  \item \textbf{drawText :} dessin de texte
  \item \textbf{putImage :} dessin d'une image
  \item \textbf{copyArea :} copie d'une zone d'un \verb|Drawable| dans un autre \verb|Drawable|
  \item \textbf{getPixel :} lecture de la couleur d'un pixel
  \item \textbf{setPixel :} écriture de la couleur d'un pixel
\end{itemize}

\vspace{1em}

Avant leur appel, la méthode \verb|prepareDrawing| du \verb|Screen| est appelée. Elle se charge de la mise à jour du contexte graphique si besoin est. Dans le cas du dessin dans une \verb|Window|, elle effectue des vérifications supplémentaires : visbilité de la fenêtre (inutile de dessiner dans une fenêtre qui n'est pas affichée à l'écran), et mise à jour de la zone de clipping.

Toutes les fonctions de dessin font alors appel à deux callbacks de dessin :
\begin{itemize}
  \item \textbf{beforeDrawing :} appelée avant de dessiner, elle reçoit en argument la zone rectangulaire dans laquelle le dessin est contenu. Elle renvoie le statut de cette zone : totalement visible, totalement masquée ou partiellement visible. Cela permet de choisir une stratégie de dessin (dessin rapide, pas de dessin du tout ou dessin en prêtant attention à ne pas écrire dans des parties masquées). Chaque classe fille de \verb|Drawable| est libre d'y ajouter les traitements qu'elle souhaite. Les \verb|Window|, par exemple, utilisent \verb|beforeDrawing| pour vérifier que le dessin ne va pas recouvrir le pointeur de la souris. Si tel est le cas, le pointeur de la souris est masqué avant le dessin.
  \item \textbf{afterDrawing :} appelée après le dessin. Les \verb|Window| l'utilisent pour redessiner le pointeur de la souris dans le cas où il a été masqué lors du \verb|beforeDrawing|.
\end{itemize}

\vspace{1em}

Pour que les primitives de dessin fonctionnent, les classes qui dérivent de \verb|Drawable| doivent implémenter deux méthodes virtuelles pures :
\begin{itemize}
  \item \textbf{pixelAddr :} indique, pour une position $(x, y)$, l'adresse en mémoire où le pixel doit être écrit (en mémoire vidéo pour les fenêtres, en mémoire vive pour les pixmaps)
  \item \textbf{isValid :} indique, pour une position $(x, y)$, s'il est possible de dessiner à cet endroit. Il faut bien sûr veiller à ne pas déborder de la fenêtre ou de la pixmap, et pour les fenêtres il faut vérifier que le point appartient bien à la zone de clipping.
\end{itemize}

\paragraph{Texte et images}
Outre les primitives de dessin classiques (dessin de formes géométriques), pron gère le dessin de texte et d'images. La gestion du texte est basée sur des polices de caractères bitmap au format BDF, qui seront présentées à la section \ref{Font}. La gestion des images est plus simple et s'apparente à la copie d'une zone rectangulaire dans une autre : l'image est passée à pron sous forme d'un vecteur de composantes RVB, et est copiée à la position voulue dans le \verb|Drawable| de destination. La taille des messages étant limitée, cela nécessite de découper les images (cf section \ref{PronlibImages}).

\subsubsection{Window}

En plus des primitives exposées par la classe \verb|Drawable|, les \verb|Window| proposent des primitives qui leur sont propres :
\begin{itemize}
  \item \textbf{map/unmap :} le ``mapping'' d'une fenêtre la rend affichable à l'écran. L'``unmapping'' est l'opération inverse. Une fenêtre n'est réellement affichée à l'écran que lorsqu'elle est ``mapped'', et que tous ses parents sont également ``mapped'' : on dit alors qu'elle est ``realized''.
  \item \textbf{clear :} efface le contenu de la fenêtre, en la remplissant avec sa couleur de fond.
  \item \textbf{\{get/set\}Attributes :} les \verb|Window| contiennent des attributs qui les caractérisent (taille, position, couleur de fond...). Les méthodes \verb|getAttributes| et \verb|setAttributes| permettent respectivement de lire et d'écrire ces attributs.
  \item \textbf{selectInput :} permet à un client de s'abonner à des événements pour cette \verb|Window|. Nous en reparlerons dans le paragraphe sur les événements.
  \item \textbf{raise/lower :} ces primitives permettent respectivement de passer une fenêtre au premier plan (devant toutes les autres) ou à l'arrière plan (derrière toutes les autres).
  \item \textbf{move/moveTo :} ces primitives permettent de déplacer la fenêtre. \verb|move| effectue un déplacement relatif à la position actuelle de la fenêtre, tandis que \verb|moveTo| effectue un déplacement relatif à la position de la fenêtre parente.
  \item \textbf{resize :} permet de redimensionner une fenêtre. Envoie un événement de redimensionnement.
\end{itemize}

\paragraph{Conditions de dessin dans une Window}
Pour pouvoir dessiner dans une \verb|Window|, il faut tout d'abord que celle-ci soit ``realized'', c'est à dire qu'elle soit mappée et que tous ses parents aussi. Cette condition est vérifiée par la méthode \verb|prepareDrawing|, avant d'exécuter la primitive de dessin demandée. Il faut également que chaque point dans lequel on souhaite dessiner appartienne à la zone de clipping. Nous reviendrons sur la notion de zone de clipping dans la section \ref{ClipZone}, mais elle peut être vue comme un ``cache'' posé sur l'écran, qui détermine les zones dans lesquelles on peut dessiner ou non.

\paragraph{Événements}\label{evenements}
Le serveur graphique communique avec ses clients via des \textbf{événements} lorsqu'il s'agit de les informer d'entrées de l'utilisateur (frappes au clavier, déplacement ou clics de la souris), ou de changements sur les fenêtres (création, destruction, exposition, redimensionnement...).

Ces événements sont envoyés au créateur de la fenêtre en fonction des types d'événements auxquels il s'est abonné. En effet, un client peut être intéressé par les événements clavier, mais pas par les événements souris. Il peut alors décider de s'abonner seulement aux événements clavier. Il construit pour cela un masque d'événements (\verb|OU| binaire des différents types d'événéments) qu'il transmet au serveur via la primitive \verb|pronSelectInput| (cf \ref{Pronlib}). L'abonnement aux événements se fait de manière individuelle pour chaque fenêtre.

En plus du créateur de la fenêtre, n'importe quel autre client peut s'abonner à des événements pour n'importe quelle fenêtre : c'est le but du vecteur \verb|OtherClients| dans le graphe de collaboration, qui contient la liste des clients intéressés par des événements sur une fenêtre (autres que son créateur), ainsi que le masque d'événements qu'ils ont choisi.

La plupart des événements sont délivrés seulement à la fenêtre pour laquelle ils ont lieu\footnote{Par ``délivrés à la fenêtre'', on entend ``délivrés à tous les clients qui sont abonnés à ce type d'événement pour cette fenêtre''} (exposition, redimensionnement...). Les événements concernant la structure des fenêtres (création, destruction, reparenting) sont également délivrés à la fenêtre parente. Enfin, les événements liés aux périphériques d'entrée (clavier et souris) se propagent de la fenêtre dans laquelle ils ont eu lieu jusqu'à la fenêtre racine, de parent en parent. Cette propagation peut être stoppée en incluant le type d'événement voulu dans le masque de non-propagation (primitive \verb|pronDontPropagateEvent|).

\subsubsection{WindowsTree}
Les fenêtres sont organisées sous la forme d'un arbre n-aire, dans lequel les frères sont doublement chaînés. La position d'une fenêtre dans la liste des fils de son père détermine sa profondeur : il y a une notion de $z$, en plus de la position $(x, y)$. Les fenêtres affichées à l'écran peuvent êtres vues comme des feuilles de papier disposées sur une table : elles peuvent se recouvrir les unes les autres, totalement ou partiellement. La convention que nous avons adoptée est que le \verb|firstChild| d'une fenêtre est son fils de $z$ le plus bas (en arrière-plan). Le \verb|lastChild| est, à l'inverse, le fils de $z$ le plus haut (en avant plan). À partir d'une fenêtre, on peut donc obtenir ses frères de $z$ inférieur (en suivant les liens \verb|prevSibling|) ou ses frères de $z$ supérieur (en suivant les liens \verb|nextSibling|).

Afin de parcourir cet arbre des fenêtres plus facilement (comme une liste, et non comme un arbre), nous avons implémenté deux itérateurs : \verb|IteratorDFS| et \verb|IteratorBFS|. Comme leur nom l'indique, ils permettent respectivement de parcourir l'arbre des fenêtres en effectuant un parcours en profondeur ou un parcours en largeur. Cela nous est très utile, notamment pour effectuer des traitements sur une fenêtre et l'ensemble de ses fils : plutôt que d'avoir recours à une fonction auxiliaire récursive, on peut simplement écrire :
\lstinputlisting{listings/iterator.cpp}

\subsubsection{ClipZone}
\label{ClipZone}

Nous avons vu que les fenêtres peuvent se superposer. Il est alors important de s'assurer qu'une fenêtre B placée en-dessous d'une autre fenêtre A ne peut pas dessiner par-dessus A. C'est le rôle de la zone de clipping, que l'on peut voir comme une sorte de ``cache'' posé sur l'écran, qui nous empêche de déborder des zones dans lesquelles on peut dessiner.

La \verb|ClipZone| contient donc un ensemble de \verb|ClipRect|, qui représentent les rectangles dans lesquels on peut dessiner. Lors de la construction de la \verb|ClipZone|, on part du rectangle délimitant la fenêtre dans laquelle on veut dessiner, et on le restreint pour qu'il ne dépasse pas des rectangles délimitant les fenêtres parentes (on ne peut pas dessiner en dehors de son parent).

On parcourt ensuite tous les frères de droite de la fenêtre (ceux qui ont un $z$ supérieur et sont donc susceptibles de la recouvrir) afin de détecter les zones recouvertes. Chaque fois qu'un rectangle jusqu'alors visible est recouvert (en totalité ou en partie), ce rectangle est découpé en rectangles plus petits afin de ne conserver que des zones non recouvertes. Ce traitement est répété pour tous les parents de la fenêtre considérée (si un des parents de la fenêtre est obscurci, la fenêtre peut l'être aussi).

Une fois la \verb|ClipZone| construite, il suffit de vérifier, pour chaque pixel à dessiner, s'il appartient ou non à un des rectangles qui la composent. Afin d'éviter d'effectuer la vérification pour chaque pixel, des optimisations ont été mises en place :
\begin{itemize}
  \item En plus de la vérification point par point, une méthode permet de vérifier si une zone rectangulaire appartient à la \verb|ClipZone|. La réponse est soit ``oui'', soit ``non'', soit ``partiellement''. Si la réponse est ``non'', on peut simplement ne pas effectuer le dessin. Si la réponse est ``oui'', le dessin peut être réalisé sans vérification supplémentaire pour chaque pixel. Sinon, on peut soit faire la vérification pixel par pixel, soit tester des zones plus petites.
  \item Lorsque l'on a demandé une vérification pour un pixel, il y a de fortes chances pour que les vérifications ultérieures portent sur des pixels voisins. Afin d'accélérer les prochaines vérifications, les réponses sont mises en cache : si le pixel demandé appartient bien à la \verb|ClipZone|, le \verb|ClipRect| dans lequel il a été trouvé est stocké dans le cache ainsi que la réponse à la vérification (``oui''). Toutes les vérifications ultérieures portant sur un pixel appartenant à ce rectangle renverront alors ``oui'' sans avoir à reparcourir l'ensemble des \verb|ClipRect| de la \verb|ClipZone|. Si le pixel demandé n'appartenait pas à la ClipZone, un algorithme recherche rapidement le plus grand rectangle qui n'appartient pas à la \verb|ClipZone| et contenant ce pixel. Toutes les vérifications ultérieures portant sur un pixel appartenant à ce rectangle pourront alors renvoyer ``non'' directement.
\end{itemize}

\subsubsection{Pixmap}

Rien de spécial à ajouter sur les \verb|Pixmap|, leur fonctionnement est relativement simple. Elles n'implémentent rien de plus que ce qui est déjà défini dans la classe \verb|Drawable|, à part les deux fonctions virtuelles \verb|pixelAddr| et \verb|isValid|. \verb|pixelAddr| se contente de renvoyer l'adresse d'un pixel dans le buffer de la pixmap ($buffer + (y * width + x) * bpp\footnote{Bytes per pixel : 1, 2 ou 3 selon la profondeur de couleurs utilisée (16 couleurs, 256 couleurs, 16 bits, 24 bits, 32 bits).}$). \verb|isValid| vérifie simplement que le point $(x, y)$ ne sort pas des limites de la pixmap $(0, 0, width, height)$.

\subsubsection{Screen}
\label{Screen}

La classe \verb|Screen| est l'entité principale de pron. Elle représente l'écran et contient toutes les fenêtres gérées par le serveur. Elle est en charge du dialogue avec le driver vidéo : c'est à la construction de l'instance de \verb|Screen| que le basculement en mode graphique est effectué, et que la résolution (largeur, hauteur et pronfondeur de couleurs) est configurée. Le rendu des fenêtres à l'écran passe également par le \verb|Screen| afin d'afficher chaque pixel au bon endroit.

Revenons maintenant sur quelques champs de la classe \verb|Screen| :
\paragraph{clipWin, mouseWin, grabWin, focusWin}
La classe \verb|Screen| contient 4 pointeurs vers des \verb|Window| jouant un rôle particulier : la \verb|clipWin| est la fenêtre pour laquelle la zone de clipping est actuellement configurée, et qui est donc prête pour le dessin. La \verb|mouseWin| est la fenêtre la plus profonde contenant le pointeur de la souris, c'est elle qui recevra les événements souris. La \verb|grabWin| est la fenêtre qui a ``grabbé'' le pointeur de la souris, c'est à dire que tous les événements souris sont redirigés vers elle, même s'ils ont eu lieu dans une autre fenêtre. Le grab peut être explicite ou implicite, un exemple de grab implicite est lors d'un drag and drop : tant que la souris n'est pas relâchée, tous les événements souris sont envoyés à la fenêtre en train d'être déplacée (celle où le bouton gauche de la souris est appuyé). Enfin, la \verb|focusWin| est la fenêtre qui a actuellement le focus, et qui recevra les événements clavier.

\paragraph{drawables}
Le \verb|Screen| contient un vecteur de \verb|Drawable| qui recense toutes les zones de dessin gérées par le serveur graphique. Celui-ci permet tout simplement de retrouver le \verb|Drawable| dans lequel un client veut dessiner lorsqu'il émet une requête : dans une requête, le \verb|Drawable| est représenté par un identifiant numérique. Le serveur graphique parcourt donc son vecteur de \verb|Drawable| afin de retrouver l'objet associé. Une structure de données beaucoup plus adaptée pour ce travail serait une \verb|map| ou une \verb|hashmap|, mais nous ne les avions pas encore implémentées lors de l'écriture de pron. Cela fera partie des améliorations futures.

\paragraph{tree}
C'est une instance de \verb|WindowsTree| qui nous permet de parcourir aisément l'arbre des fenêtres grâce à deux itérateurs : l'un effectue un parcours en profondeur, l'autre un parcours en largeur. Cela nous permet notamment d'effectuer des traitements sur l'ensemble des fils d'une fenêtre, sans recourir à des fonctions récursives.

\paragraph{gc}
Il s'agit tout simplement du contexte graphique courant, qui sera utilisé par toutes les primitives de dessin. Il est configuré en amont de l'appel des primitives de dessin, lors de la réception de la requête du client, via la méthode \verb|prepareDrawing|.

\paragraph{fonts}
Le \verb|Screen| contient la liste des polices de caractères chargées au démarrage du serveur sous la forme d'un vecteur de \verb|Font|. Lorsqu'un client demande à afficher du texte, le dessin est délégué à l'objet \verb|Font| correspondant à la police demandée. Il est identifié dans le contexte graphique par son indice dans ce vecteur.

\paragraph{clipZone}
Il s'agit de la zone de clipping actuellement configurée pour la \verb|clipWin|. Cela signifie que le dessin se fait dans le contexte de la \verb|clipWin| : on ne peut dessiner ni en dehors de cette fenêtre, ni dans des zones de cette fenêtre recouvertes par d'autres fenêtres.

\subsubsection{Font}
\label{Font}
Nous avons choisi d'implémenter un support des polices de caractères au format BDF (Glyph Bitmap Distribution Format). Nous avons choisi ce format car il se présente sous la forme d'un fichier texte à la fois lisible par des humains et très facile à parser. De plus, la manipulation de polices bitmap est beaucoup simple que la manipulation de polices vectorielles, malgré les limitations que cela engendre (pas de redimensionnement notamment, et donc un fichier différent par taille de police).

Nous proposons deux primitives de manipulation du texte :
\begin{itemize}
  \item \textbf{drawText :} comme son nom l'indique, elle permet de dessiner du texte à une position $(x, y)$ donnée. Notons tout de même que cette primitive permet d'aligner le texte par rapport à cette position, horizontalement (aligné à gauche, à droite ou centré) et verticalement (aligné en haut, en bas ou au milieu).
  \item \textbf{textSize :} elle permet de connaître la taille d'un texte rendu avec la police demandée (largeur et hauteur). Elle est notamment utile lorsque l'on veut wrapper du texte.
\end{itemize}

\vspace{1em}

Ces deux primitives utilisent la police de caractères configurée dans le contexte graphique courant.

\subsubsection{Client}
Très peu de choses à dire sur la classe \verb|Client|, si ce n'est qu'elle représente un client et se charge de la communication avec lui. La méthode principale, \verb|handle|, vérifie si un nouveau message est disponible sur la socket associée à ce client, et le traite via un \verb|switch| sur le type de message. Ce \verb|switch| se présente comme un contrôleur : il vérifie le type de message (toujours une requête pour un client) ainsi que la validité des paramètres de la requête (identifiant de la fenêtre ou pixmap dans laquelle il veut dessiner, du contexte graphique à utiliser...). C'est à ce moment que la méthode de préparation de dessin (\verb|prepareDrawing|) est appelée, pour configurer le nouveau contexte graphique notamment, et que la primitive demandée par le client est appelée.

\verb|handle| détecte également la déconnexion du client, ce qui déclenche la destruction de l'objet \verb|Client| associé. Le destructeur se charge alors de détruire toutes les ressources allouées par ce client (fenêtres, pixmaps et contextes graphiques).

\subsubsection{Keyboard/Mouse}

Ces deux entités permettent de dialoguer avec le clavier et la souris. Ce sont eux qui communiquent avec les drivers de ces deux périphériques d'entrée. Leur méthode principale, \verb|checkEvents|, détecte si un nouvel événement a eu lieu (touche du clavier appuyée ou relâchée, souris déplacée...) et effectue les actions appropriées en conséquence.

Dans le cas d'un événement clavier, c'est très simple : on envoie simplement un événement \verb|EventKeyPressed| ou \verb|EventKeyReleased| à la fenêtre qui a le focus (\verb|focusWin|).

Dans le cas d'un événement souris, il y a deux cas de figure à traiter :
\begin{itemize}
  \item La souris a bougé : après avoir sauvegardé les nouvelles coordonnées de la souris, on procède en 3 étapes.
    \begin{itemize}
      \item Il faut tout d'abord déplacer le pointeur à l'écran en conséquence. Pour cela, avant chaque dessin du pointeur, la zone dans laquelle il s'apprête à être dessiné est sauvegardée. Cette sauvegarde peut ensuite être restaurée afin de faire disparaître le pointeur de son ancienne position, avant de le redessiner à sa nouvelle position.
      \item Il faut ensuite mettre à jour la fenêtre qui contient le pointeur de la souris (\verb|mouseWin|). Pour cela, on part simplement de la fenêtre racine, et on descend en prenant la fenêtre ``realized'' de $z$ maximal qui contient le curseur. On obtient ainsi la fenêtre la plus ``profonde'' dans l'arbre, visible à l'écran, qui contient le pointeur de la souris.
      \item On envoie ensuite un événement \verb|EventPointerMoved| à la \verb|mouseWin| fraîchement mise à jour.
    \end{itemize}
  \item L'état des boutons de la souris a changé : après avoir sauvegardé le nouvel état des boutons, on envoie simplement un événement \verb|EventMouseButton| à la \verb|mouseWin|.
\end{itemize}

\paragraph{Grabs} Comme vu à la section \ref{Screen}, une fenêtre peut ``grabber'' le pointeur de la souris. Tous les événements souris sont alors redirigés vers elle, même s'ils ont eu lieu dans une autre fenêtre. Cela se traduit simplement par un envoi des événements à la \verb|grabWin| au lieu de la \verb|mouseWin| lorsque la \verb|grabWin| n'est pas \verb|NULL|. Pour l'instant, nous ne supportons que les ``grabs'' implicites, c'est à dire lorsque le bouton gauche de la souris est enfoncé dans une fenêtre. La mise à jour de la \verb|grabWin| est donc très simple : lorsque l'on détecte un changement d'état des boutons et que le bouton gauche est enfoncé, la \verb|mouseWin| devient la \verb|grabWin|. Lorsque ce bouton est relâché, la \verb|grabWin| redevient \verb|NULL|.

\subsection{Boucle principale de Pron}

Le listing ci-dessous illustre le fonctionnement très simple de la boucle principale de pron. On commence par accepter les éventuels nouveaux clients en attente de connexion. On vérifie ensuite, pour chaque client, s'il a envoyé une requête qu'il faut traiter. La déconnexion des clients est gérée à ce niveau (dans le \verb|handle| des objets \verb|Client|). Enfin, on vérifie si les périphériques d'entrée ne nous ont pas remonté de nouveaux événements.

\lstinputlisting{listings/pron_main.cpp}

\subsection{Pronlib : librairie cliente de Pron}
\label{Pronlib}

La pronlib est la librairie cliente de pron. Elle permet aux applications d'interagir avec le serveur graphique : connexion, création et manipulation de fenêtres, dessin, gestion des événements... C'est une librairie relativement bas niveau : chaque primitive qu'elle propose correspond à une primitive de pron. Les fonctions de la pronlib se contentent de forger une requête pron à partir des arguments qu'elles reçoivent, et d'envoyer cette requête au serveur. Certaines d'entre elles attendent ensuite la réponse du serveur pour la transmettre à l'application.

\subsubsection{Notion de ``Display''}

Le \verb|Display| est une entité spécifique à la pronlib. Il représente la ``connexion'' à pron, établie par la primitive \verb|pronConnect|. Il est passé comme premier argument à toutes les primitives de la pronlib.

La connexion à pron consiste en l'envoi d'une requête \verb|Hello|. Pron envoie alors une réponse \verb|Welcome| contenant l'identifiant de la root window (0 par convention) ainsi que la plage d'identifiants que le nouveau client peut utiliser pour créer des ressources.

Nous avons en effet vu à la section \ref{Architecture} que pour des raisons de performances, c'est le client lui-même qui choisit les identifiants des ressources qu'il veut créer. Cette tâche est en réalité prise en charge par la pronlib, afin de l'abstraire à l'application. La page d'identifiants transmise dans la réponse \verb|Welcome| est stockée dans le \verb|Display| qui peut alors tenir un compteur d'identifiants incrémenté à chaque création de nouvelle ressource (fenêtre, pixmap, contexte graphique...).

Le \verb|Display| abstrait également la lecture de messages depuis le serveur. En effet, l'application est susceptible de recevoir trois types de messages de la part du serveur :
\begin{itemize}
  \item Une réponse, attendue à la suite de certaines requêtes (attributs d'une fenêtre, valeurs d'un contexte graphique...). La pronlib attend alors un type de réponse spécifique pour pouvoir le remonter à l'application. Si elle reçoit un message qui ne correspond pas, elle doit lever une erreur. Si elle reçoit un événement, elle doit le placer dans une file pour qu'il puisse être consulté lors de la prochaine lecture des événements, et se remettre en attente de la réponse.
  \item Un événement, attendu suite à l'appel de la primitive de lecture des événements (\verb|pronNextEvent|). Si des événements sont présents dans la file d'attente
  \item Une erreur. Quel que soit le contexte dans lequel la réception d'un message d'erreur a lieu (attente d'une réponse à une requête ou d'un événement), il est transmis à un gestionnaire d'erreur qui peut agir en conséquence. Pour l'instant, le gestionnaire d'erreur est extrêmement basique et se contente de quitter l'application.
\end{itemize}

\vspace{1em}

Le \verb|Display| permet donc à la pronlib de gérer ces différents cas de figure aisément en proposant une méthode \verb|read(MessageType type)| de ``haut niveau'', permettant de recevoir un message de type prédéfini (réponse à une requête, événement) tout en prenant en charge tous ces détails.

\subsubsection{Gestion des événements}

Toute application utilisant la pronlib doit contenir une boucle de gestion des événements. C'est grâce à cette boucle qu'elle est notifiée des différents éléments qui vont survenir pendant toute la vie de l'application : entrées de l'utilisateur, exposition de la fenêtre, redimensionnement, fermeture...

La primitive \verb|pronNextEvent| permet à l'application de récupérer le prochain événement transmis par le serveur. Comme toutes les primitives de la pronlib, son premier argument est le \verb|Display|. Son deuxième argument est une structure \verb|PronEvent|, qui doit être préalablement allouée via la primitive \verb|getPronEvent|. Ce \verb|PronEvent| n'a besoin d'être alloué qu'une seule fois (avant de rentrer dans la boucle de gestion des événements) et peut être ensuite réutilisé par chaque appel à \verb|pronNextEvent|. Enfin, le dernier argument définit le comportement de la primitive en cas d'absence de nouvel événement : par défaut, \verb|pronNextEvent| est bloquante et attendra jusqu'à la réception d'un nouvel événement.

L'application peut demander à ce que la lecture des événements soit non bloquante en passant le troisième argument \verb|nonBlocking| à ``vrai''. Dans ce cas, en l'absence d'événement à retourner, \verb|pronNextEvent| retournera immédiatement avec un code de retour égal à 0 (``faux''). Pour distinguer une absence d'événement d'une erreur de lecture, l'application pourra utiliser le même mécanisme que pour la manipulation de sockets non bloquantes, via la variable globale \verb|errno|.

Un exemple de boucle de gestion des événements est donné à la section \ref{Squelette}.

\subsubsection{Gestion des images}
\label{PronlibImages}

La seule primitive non triviale de la pronlib est \verb|pronPutImage|. En effet, il faut d'une manière ou d'une autre transférer l'image sur le serveur, image dont la taille est bien souvent supérieure à la taille maximale d'un message pron\footnote{Pour l'instant 1Kio, mais augmenter cette taille ne fait que repousser le problème.}. \verb|pronPutImage| se charge donc de segmenter l'image en autant de messages que nécessaire. Chaque message est une requête \verb|PutImage| qui contient l'identifiant du \verb|Drawable| dans lequel dessiner, la position $(x, y)$ à laquelle dessiner l'image, sa taille (largeur et hauteur), son format (seul le format ZPixmap\footnote{Simple vecteur de composantes RVB.} est supporté pour le moment) et sa profondeur de couleurs. Le reste du message contient le fragment d'image à transmettre. Pour que l'image soit correctement réassemblée côté serveur, deux informations sont ajoutées dans chaque message : l'offset du fragment actuel, ainsi que sa taille.

\subsubsection{Liste des primitives de la pronlib}

\lstinputlisting{listings/pronlib.h}

\subsubsection{Squelette d'application utilisant la pronlib}
\label{Squelette}

\lstinputlisting{listings/appli_pronlib.cpp}

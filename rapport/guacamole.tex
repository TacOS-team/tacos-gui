\section{Guacamole}

Guacamole est notre gestionnaire de fenêtres flottantes.
Nous allons commencer par rappeller rapidement le rôle d'un gestionnaire de fenêtres mais pour avoir plus de détails, il est conseillé de lire le rapport bibliographique.
Le gestionnaire de fenêtres est l'acteur permettant de :

\begin{itemize}
  \item Décorer\footnote{La décoration d'une fenêtre est le cadre qui contient son titre ainsi que des boutons permettant de la manipuler.} les fenêtres
  \item Fermer, déplacer et redimensionner les fenêtres
  \item Gérer la navigation entre les fenêtres et leur passage au premier plan
  \item Gérer le plein écran et les maximisations des fenêtres
\end{itemize}

\subsection{Création d'une fenêtre par un client}

Dans l'architecture que nous avons mise en place, Guacamole est un client comme tous les autres.
Il n'a pas un ``statut'' différent des autres clients et ne fait que s'abonner à des événements en plus.
Pour faire son travail, il a besoin d'être averti lors de la création d'une fenêtre et lors de sa destruction.
Il s'abonne donc aux événements correspondants.
Lorsqu'on lance notre système, on a donc Pron et Guacamole qui sont deux entités distinctes comme ci-dessous.

\begin{figure}[H]
  \centering
  \includegraphics[width=8cm]{images/Guacamole_anim_1.jpg}
  \caption{Guacamole et Pron}
  \label{fig:guacamole_anim_1}
\end{figure}

Lorsqu'une application graphique démarre, elle se connecte à Pron et envoie une requête de création d'une fenêtre.

\begin{figure}[H]
  \centering
  \includegraphics[width=8cm]{images/Guacamole_anim_2.jpg}
  \caption{Demande de création d'une fenêtre}
  \label{fig:guacamole_anim_2}
\end{figure}

Dès la réception de ce message, Pron crée la fenêtre sans décoration : pour lui, une fenêtre n'est rien d'autre qu'une zone de dessin rectangulaire.
Le nouvel arbre interne des fenêtres de Pron sera le suivant après le lancement de l'application \verb|PronCube| :

\begin{center}
  \begin{tikzpicture}[
    grow via three points={one child at (0.5,-0.7) and
    two children at (0.5,-0.7) and (0.5,-1.4)},
    edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
    \node [root] {Root Window}
      child { node {PronCube}};
  \end{tikzpicture}
\end{center}

Pron envoie ensuite un événement de création de fenêtre, sous réserve qu'une application s'y soit abonnée.
Si Guacamole n'a pas été lancé, on a donc une fenêtre non décorée qui apparaît à l'écran.
Le client fonctionne parfaitement et se présente comme ceci :

\begin{figure}[H]
  \centering
  \includegraphics[width=8cm]{images/pron_cube_sans_decoration.jpg}
  \caption{Application PronCube sans décoration}
  \label{fig:pron_cube_sans_decoration}
\end{figure}

En revanche, si Guacamole est lancé, il reçoit la notification de création de la fenêtre.

\begin{figure}[H]
  \centering
  \includegraphics[width=8cm]{images/Guacamole_anim_3.jpg}
  \caption{Notification de Guacamole de la création d'une fenêtre}
  \label{fig:guacamole_anim_3}
\end{figure}

Ce message contient plusieurs informations intéressantes :

\begin{itemize}
  \item L'identifiant Pron de la nouvelle fenêtre
  \item L'identifiant Pron de la fenêtre parente
  \item Un booléen autorisant ou non la décoration de la fenêtre
\end{itemize}

Une fois ce message reçu, Guacamole décore la fenêtre si deux conditions sont réunies :

\begin{itemize}
  \item Le booléen autorisant la décoration est ``vrai''
  \item La fenêtre est une ``top window'', c'est à dire que son parent est la root window (fenêtre de premier niveau dans l'arbre des fenêtres)
    \footnote{On rappelle que chaque application peut créer plusieurs fenêtres à l'intérieur de sa propre fenêtre pour créer les divers éléments graphiques (boutons, labels, et tout autre widget). Seules les fenêtres ``principales'' doivent être décorées : on ne souhaite pas qu'un bouton ou un label le soit.} 
\end{itemize}

Si la fenêtre doit être décorée, Guacamole ajoute cette fenêtre à sa liste interne de fenêtres décorées.
Il crée ensuite la fenêtre de décoration, qui est une fenêtre un peu plus grande que la fenêtre du client.
Elle dépasse notament au dessus pour afficher la décoration.
Guacamole envoie donc une requête à Pron :

\begin{figure}[H]
  \centering
  \includegraphics[width=8cm]{images/Guacamole_anim_4.jpg}
  \caption{Création de la fenêtre de décoration}
  \label{fig:guacamole_anim_4}
\end{figure}

Du coté de Pron, le nouvel arbre des fenêtres est donc le suivant :

\begin{center}
  \begin{tikzpicture}[
    grow via three points={one child at (0.5,-0.7) and
    two children at (0.5,-0.7) and (0.5,-1.4)},
    edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
    \node [root] {Root Window}
      child { node {Décoration de PronCube}}
      child { node {PronCube}};
  \end{tikzpicture}
\end{center}

Guacamole définit ensuite la fenêtre de décoration comme fenêtre parente de la fenêtre de l'application\footnote{Cette opération porte le nom de ``reparenting''.}, qu'il place à la bonne position à l'intérieur de son nouveau parent.
Il envoie donc une requête à Pron.

\begin{figure}[H]
  \centering
  \includegraphics[width=8cm]{images/Guacamole_anim_5.jpg}
  \caption{Reparenting de la fenêtre de l'application}
  \label{fig:guacamole_anim_5}
\end{figure}

Le nouvel arbre des fenêtres de Pron est donc le suivant :

\begin{center}
  \begin{tikzpicture}[
    grow via three points={one child at (0.5,-0.7) and
    two children at (0.5,-0.7) and (0.5,-1.4)},
    edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
    \node [root] {Root Window}
      child { node {Décoration de PronCube}
        child { node {PronCube}}
      };
  \end{tikzpicture}
\end{center}

Maintenant que la fenêtre de décoration est créée et la fenêtre de l'application correctement placée à l'intérieur, il reste deux choses à faire :

\begin{itemize}
  \item Créer les boutons de fermeture, maximisation et redimensionnement de la fenêtre
  \item Trouver un emplacement libre sur l'écran et y déplacer la fenêtre
\end{itemize}

Les boutons de fermeture sont de nouvelles fenêtres Pron, pour lesquelles Guacamole va s'abonner à divers événements que nous présenterons à la section \ref{GestionFenetres}.
Ces boutons sont créés à l'intérieur de la fenêtre de décoration, qui est leur fenêtre parente.
Guacamole envoie donc à Pron plusieurs requêtes de création de fenêtre :

\begin{figure}[H]
  \centering
  \includegraphics[width=8cm]{images/Guacamole_anim_6.jpg}
  \caption{Création des boutons par Guacamole}
  \label{fig:guacamole_anim_6}
\end{figure}

Le nouvel arbre de fenêtres de Pron est maintenant :

\begin{center}
  \begin{tikzpicture}[
    grow via three points={one child at (0.5,-0.7) and
    two children at (0.5,-0.7) and (0.5,-1.4)},
    edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
    \node [root] {Root Window}
      child { node {Décoration de PronCube}
        child { node {Bouton de fermeture}}
        child { node {Bouton de maximisation}}
        child { node {Bouton de redimensionnement}}
        child { node {PronCube}}
      };
  \end{tikzpicture}
\end{center}

L'affichage devient alors :

\begin{figure}[H]
  \centering
  \includegraphics[width=8cm]{images/pron_cube_avec_decoration.jpg}
  \caption{Application PronCube avec décoration}
  \label{fig:pron_cube_avec_decoration}
\end{figure}

On voit bien la décoration au dessus de la fenêtre avec le titre de la fenêtre à gauche, et les boutons de maximisation et de fermeture à droite.
Le bouton de redimensionnement se trouve quand à lui en bas à droite de la fenêtre\footnote{Petit carré plus clair en premier plan.}.

\subsection{Gestion des fenêtres}
\label{GestionFenetres}

Maintenant que nos fenêtres sont décorées, nous avons à notre disposition tous les éléments permettant à l'utilisateur de les manipuler.
Pour pouvoir réagir aux actions de l'utilisateur, il ne reste plus qu'à s'abonner à différents événements.

\subsubsection{Fermeture et maximisation}

La gestion de la fermeture et de la maximisation est assez simple, il suffit de s'abonner aux événements de clics sur les boutons correspondants.

Pour la fermeture, lorsqu'un clic est détecté, il faut détruire la fenêtre de décoration.
La destruction d'une fenêtre entraînant celle de toutes ses filles, cela détruira également la fenêtre de l'application.
Pron enverra donc à l'application un événement de destruction, et elle se terminera proprement.

La maximisation est également effectuée lors du clic sur le bouton de maximisation.
Pour maximiser la fenêtre, il faut redimensionner la fenêtre de décoration pour qu'elle occupe la totalité de l'écran (taille de la root window) et la placer aux coordonnées $(0, 0)$.
Il faut également redimensionner la fenêtre de l'application et changer le dessin du bouton de maximisation, qui devient un bouton ``restaurer''.
La taille et la position de la fenêtre sont sauvegardées avant la maximisation, afin de pouvoir être rétablies lors du clic sur le bouton de restauration.

\subsubsection{Déplacement et redimensionnement}

Le déplacement et le redimensionnement sont assez particuliers, car il faut à la fois gérer le clic et les mouvements de la souris.
Pour le déplacement, lors du clic sur la barre de décoration, on s'abonne aux événements de déplacement de la souris.
On passe ensuite dans un état ``redimensionnement''.
À chaque mouvement de souris, on déplace la fenêtre de décoration d'autant de pixels que la souris s'est déplacée.

Lors d'un déplacement d'une fenêtre par Pron, il déplace automatiquement toutes les fenêtres filles.
Il n'est donc pas nécessaire de déplacer toutes les fenêtres une par une, seulement la fenêtre mère qui est la fenêtre de décoration.
Afin d'optimiser les performances, lors du déplacement, on évite de redessiner la fenêtre à chaque événement de mouvement de la souris, qui sont très nombreux.
Pour cela, au début du déplacement, on ``unmap'' la fenêtre de l'application.
Puis, lorsque l'utilisateur relâche la souris, on ``remap'' la fenêtre qui s'affiche de nouveau une seule fois.

Pour le redimensionnement, le principe est exactement le même, à ceci près que l'on que l'on passe dans un état ``redimensionnement''.
Une fois le redimensionnement terminé, la fenêtre de l'application est ``remappée'' et informée qu'elle a été redimensionnée.
C'est ensuite à elle de mettre à jour les tailles de ses fenêtres filles si besoin et de les afficher de nouveau.

\subsection{Implémentation}

À l'heure de l'écriture de ce document, Guacamole a été développé directement avec la Pronlib.
La Pronlib offrant un niveau d'abstraction quasi nul, le code de Guacamole est assez dense et complexe : le dispatching des événements est géré manuellement dans le \verb|main|, les boutons sont gérés ``à la main'' grâce aux événements souris...
Afin d'alléger le code de Guacamole et de se concentrer sur son objectif principal (la gestion des fenêtres), il serait bénéfique de le réimplémenter en utilisant Sombrero, notre librairie de widgets.
